{"ast":null,"code":"import * as fs from 'fs'; // use this for esmodules and typescript\n\nexport class Anagram {\n  constructor(dictionaryFile) {\n    this.dictionaryFile = dictionaryFile;\n    this.dictionary = [];\n    this.sortedDictionary = [];\n    this.dictionaryArr = void 0;\n    this.client = void 0;\n    this.anagramMap = void 0;\n    // easier to read tweak vars up front\n    this.anagramSources = [\"http://localhost:3000/\", \"http://localhost:3000/anagrams/anagram.txt\", \"http://localhost:3000/anagrams/anagram.sample.txt\"];\n    this.anagramMap = new Map();\n    this.dictionaryFile = dictionaryFile; // loads dictionary file\n    /*if (!fs.existsSync(this.dictionaryFile)) {\r\n      throw new Error('File not found!');\r\n    }*/\n\n    // open closed principle (SOLID)\n    Object.freeze(this.anagramSources);\n    this.anagramSources.forEach(source => this.loadAnagrams(source));\n  }\n  async loadAnagrams(source) {\n    let lines;\n    try {\n      var _lines;\n      let responseTextMultiLine = await this.fetchAnagram(source);\n      lines = responseTextMultiLine === null || responseTextMultiLine === void 0 ? void 0 : responseTextMultiLine.split('\\r\\n');\n      (_lines = lines) === null || _lines === void 0 ? void 0 : _lines.forEach(line => {\n        this.lineToMap(line);\n      });\n    } catch (err) {\n      console.log(`Error fetching ${source}: ${err}`);\n    }\n  }\n  lineToMap(line) {\n    try {\n      let anagramEntry = line.split(',');\n      this.anagramMap.set(anagramEntry[0], this.nToEnd(1, anagramEntry).join(','));\n    } catch (err) {\n      console.log(`Error parsing line: ${line}`);\n    }\n  }\n  nToEnd(n, arr) {\n    return arr.slice(n);\n  }\n  async fetchAnagram(source) {\n    let responseTextMultiLine;\n    try {\n      let response = await fetch(source); // timeout?, json?\n      responseTextMultiLine = await response.text();\n      return responseTextMultiLine;\n    } catch (err) {\n      console.log(`Error fetching ${source}: ${err}`);\n    }\n  }\n  async setup() {\n    //await this.client.connect();\n    let dictionaryArr = this.loadDictionaryIntoArray();\n    //this.sortedDictionary = await this.sortDictionaryWordsIntoRedis(dictionaryArr);\n  }\n\n  // how to preload the dictionary?\n  /*\r\n  async readAnagramsFromRedis(sortedWordKey: string) : Promise<string> {\r\n    let commaSeparatedAnagrams = await this.client.get(sortedWordKey);\r\n    let anagramsArr = commaSeparatedAnagrams.split(',').filter((item) => item.match(/^[a-z]+/)); // filter out empty strings\r\n    let anagramsWithCommas = anagramsArr.join(',');\r\n    return anagramsWithCommas;\r\n  }*/\n\n  async setAnagrams(wordKey, anagramsCommaSeperated) {\n    let anagrams = anagramsCommaSeperated.split(',');\n    let cleaned = anagrams.filter(item => item.match(/^[a-z]+/));\n    //let uniqueAnagrams = [...new Set(cleaned)];\n    //let anagramsUniqueCommaSeperated = uniqueAnagrams.join(',');\n\n    //await this.client.set(wordKey, anagramsUniqueCommaSeperated);\n  }\n\n  search(word) {\n    let sortedWordKey = this.sortStr(word);\n    let anagrams = this.anagramMap.get(sortedWordKey);\n    return anagrams || 'Anagrams not found';\n    /*return new Promise((resolve, reject) => {\r\n      resolve(anagrams || 'Anagrams not found');\r\n    });*/\n  }\n\n  loadDictionaryIntoArray() {\n    var dictionary = fs.readFileSync(this.dictionaryFile, 'utf8').split('\\r\\n');\n    return dictionary;\n  }\n  validateAlpha(word) {\n    if (word.match(/^[a-z]+$/)) {\n      return true;\n    }\n    return false;\n  }\n  validateValues(word) {\n    if (word.match(/^[a-z]+,?$/)) {\n      return true;\n    }\n    return false;\n  }\n\n  // sorts the entire file and stores it in a hash map\n  async sortDictionaryWordsIntoRedis(dictionary) {\n    // array passed by reference\n    // node js doesn't have tail call recursion so we use a loop\n    for (let word of dictionary) {\n      // will compare words by sorting each char in ascending order\n      let sortedWordKey = this.sortStr(word);\n      //let preExistingWordsInValue = await this.readAnagramsFromRedis(sortedWordKey);\n      //await this.setAnagrams(sortedWordKey, preExistingWordsInValue + this.comma(word));\n    }\n  }\n\n  preCommaWord(word) {\n    if (word) return `,${word}`;\n  }\n\n  // NodeJS is probably using merge sort\n  sortStr(word) {\n    return word.split('').sort().join('');\n  }\n}","map":{"version":3,"names":["fs","Anagram","constructor","dictionaryFile","dictionary","sortedDictionary","dictionaryArr","client","anagramMap","anagramSources","Map","Object","freeze","forEach","source","loadAnagrams","lines","_lines","responseTextMultiLine","fetchAnagram","split","line","lineToMap","err","console","log","anagramEntry","set","nToEnd","join","n","arr","slice","response","fetch","text","setup","loadDictionaryIntoArray","setAnagrams","wordKey","anagramsCommaSeperated","anagrams","cleaned","filter","item","match","search","word","sortedWordKey","sortStr","get","readFileSync","validateAlpha","validateValues","sortDictionaryWordsIntoRedis","preCommaWord","sort"],"sources":["C:/Users/nates/Pro/anagrams/react/src/lib/Anagram.ts"],"sourcesContent":["\r\nimport * as fs from 'fs';    // use this for esmodules and typescript\r\n\r\nexport class Anagram {\r\n  public dictionary: string[] = []; \r\n  public sortedDictionary : string[] = [];\r\n  public dictionaryArr: string[] | undefined;\r\n  public client: any;\r\n  public anagramMap: Map<string, string>;\r\n  // easier to read tweak vars up front\r\n  public anagramSources = [\"http://localhost:3000/\", \"http://localhost:3000/anagrams/anagram.txt\", \"http://localhost:3000/anagrams/anagram.sample.txt\"];\r\n  \r\n  constructor(public dictionaryFile: string) {\r\n    this.anagramMap = new Map<string, string>();\r\n    this.dictionaryFile = dictionaryFile; // loads dictionary file\r\n    /*if (!fs.existsSync(this.dictionaryFile)) {\r\n      throw new Error('File not found!');\r\n    }*/\r\n\r\n    // open closed principle (SOLID)\r\n    Object.freeze(this.anagramSources);\r\n    \r\n    this.anagramSources.forEach((source) => this.loadAnagrams(source));\r\n  }\r\n\r\n  async loadAnagrams(source: string) {\r\n    let lines;\r\n    try {\r\n      let responseTextMultiLine = await this.fetchAnagram(source);\r\n      lines = responseTextMultiLine?.split('\\r\\n');\r\n      lines?.forEach((line) => {\r\n        this.lineToMap(line);\r\n      });\r\n    } catch (err) {\r\n      console.log(`Error fetching ${source}: ${err}`);\r\n    }\r\n  }\r\n\r\n  lineToMap(line: string) {\r\n    try {\r\n      let anagramEntry = line.split(',');\r\n      this.anagramMap.set(anagramEntry[0], this.nToEnd(1, anagramEntry).join(','));\r\n    } catch (err) {\r\n      console.log(`Error parsing line: ${line}`);\r\n    }\r\n  }\r\n\r\n  nToEnd(n : number, arr : string[]) {\r\n    return arr.slice(n);\r\n  }\r\n\r\n  async fetchAnagram(source: string) : Promise<string | undefined> {\r\n    let responseTextMultiLine : string;\r\n    try {\r\n      let response = await fetch(source); // timeout?, json?\r\n      responseTextMultiLine = await response.text();\r\n      return responseTextMultiLine;\r\n    } catch (err) {\r\n      console.log(`Error fetching ${source}: ${err}`);\r\n    }\r\n  }\r\n\r\n\r\n  async setup() {\r\n    //await this.client.connect();\r\n    let dictionaryArr = this.loadDictionaryIntoArray();\r\n    //this.sortedDictionary = await this.sortDictionaryWordsIntoRedis(dictionaryArr);\r\n  }\r\n\r\n  // how to preload the dictionary?\r\n  /*\r\n  async readAnagramsFromRedis(sortedWordKey: string) : Promise<string> {\r\n    let commaSeparatedAnagrams = await this.client.get(sortedWordKey);\r\n    let anagramsArr = commaSeparatedAnagrams.split(',').filter((item) => item.match(/^[a-z]+/)); // filter out empty strings\r\n    let anagramsWithCommas = anagramsArr.join(',');\r\n    return anagramsWithCommas;\r\n  }*/\r\n\r\n  async setAnagrams(wordKey: string, anagramsCommaSeperated: string) {\r\n    let anagrams = anagramsCommaSeperated.split(',');\r\n    let cleaned = anagrams.filter((item) => item.match(/^[a-z]+/));\r\n    //let uniqueAnagrams = [...new Set(cleaned)];\r\n    //let anagramsUniqueCommaSeperated = uniqueAnagrams.join(',');\r\n\r\n    //await this.client.set(wordKey, anagramsUniqueCommaSeperated);\r\n  }\r\n\r\n  search(word: string) : string {\r\n    let sortedWordKey = this.sortStr(word);\r\n    let anagrams = this.anagramMap.get(sortedWordKey);\r\n    return anagrams || 'Anagrams not found';\r\n    /*return new Promise((resolve, reject) => {\r\n      resolve(anagrams || 'Anagrams not found');\r\n    });*/\r\n  }\r\n\r\n  loadDictionaryIntoArray(): string[] {\r\n    var dictionary: string[] = fs.readFileSync(this.dictionaryFile, 'utf8').split('\\r\\n');\r\n    return dictionary;\r\n  }\r\n\r\n  validateAlpha(word: string) {\r\n    if(word.match(/^[a-z]+$/)) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  validateValues(word: string) {\r\n    if(word.match(/^[a-z]+,?$/)) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // sorts the entire file and stores it in a hash map\r\n  async sortDictionaryWordsIntoRedis(dictionary: string[]) { // array passed by reference\r\n    // node js doesn't have tail call recursion so we use a loop\r\n    for(let word of dictionary) {\r\n      // will compare words by sorting each char in ascending order\r\n      let sortedWordKey = this.sortStr(word);\r\n      //let preExistingWordsInValue = await this.readAnagramsFromRedis(sortedWordKey);\r\n      //await this.setAnagrams(sortedWordKey, preExistingWordsInValue + this.comma(word));\r\n    }\r\n  }\r\n\r\n  preCommaWord(word: string) {\r\n    if(word) return `,${word}`;\r\n  }\r\n  \r\n  // NodeJS is probably using merge sort\r\n  sortStr(word: string) : string {\r\n    return word.split('').sort().join(''); \r\n  }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}