{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Anagram = void 0;\nconst fs = __importStar(require(\"fs\")); // use this for esmodules and typescript\nclass Anagram {\n  constructor(dictionaryFile) {\n    this.dictionaryFile = dictionaryFile;\n    this.dictionary = [];\n    this.sortedDictionary = [];\n    // easier to read tweak vars up front\n    this.anagramSources = [\"http://localhost:3000/\", \"http://localhost:3000/anagrams/anagram.txt\", \"http://localhost:3000/anagrams/anagram.sample.txt\"];\n    this.anagramMap = new Map();\n    this.dictionaryFile = dictionaryFile; // loads dictionary file\n    /*if (!fs.existsSync(this.dictionaryFile)) {\n      throw new Error('File not found!');\n    }*/\n    // open closed principle (SOLID)\n    Object.freeze(this.anagramSources);\n    this.anagramSources.forEach(source => this.loadAnagrams(source));\n  }\n  loadAnagrams(source) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let lines;\n      try {\n        let responseTextMultiLine = yield this.fetchAnagram(source);\n        lines = responseTextMultiLine === null || responseTextMultiLine === void 0 ? void 0 : responseTextMultiLine.split('\\r\\n');\n        lines === null || lines === void 0 ? void 0 : lines.forEach(line => {\n          this.lineToMap(line);\n        });\n      } catch (err) {\n        console.log(`Error fetching ${source}: ${err}`);\n      }\n    });\n  }\n  lineToMap(line) {\n    try {\n      let anagramEntry = line.split(',');\n      this.anagramMap.set(anagramEntry[0], this.nToEnd(1, anagramEntry).join(','));\n    } catch (err) {\n      console.log(`Error parsing line: ${line}`);\n    }\n  }\n  nToEnd(n, arr) {\n    return arr.slice(n);\n  }\n  fetchAnagram(source) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let responseTextMultiLine;\n      try {\n        let response = yield fetch(source); // timeout?, json?\n        responseTextMultiLine = yield response.text();\n        return responseTextMultiLine;\n      } catch (err) {\n        console.log(`Error fetching ${source}: ${err}`);\n      }\n    });\n  }\n  setup() {\n    return __awaiter(this, void 0, void 0, function* () {\n      //await this.client.connect();\n      let dictionaryArr = this.loadDictionaryIntoArray();\n      //this.sortedDictionary = await this.sortDictionaryWordsIntoRedis(dictionaryArr);\n    });\n  }\n  // how to preload the dictionary?\n  /*\n  async readAnagramsFromRedis(sortedWordKey: string) : Promise<string> {\n    let commaSeparatedAnagrams = await this.client.get(sortedWordKey);\n    let anagramsArr = commaSeparatedAnagrams.split(',').filter((item) => item.match(/^[a-z]+/)); // filter out empty strings\n    let anagramsWithCommas = anagramsArr.join(',');\n    return anagramsWithCommas;\n  }*/\n  setAnagrams(wordKey, anagramsCommaSeperated) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let anagrams = anagramsCommaSeperated.split(',');\n      let cleaned = anagrams.filter(item => item.match(/^[a-z]+/));\n      //let uniqueAnagrams = [...new Set(cleaned)];\n      //let anagramsUniqueCommaSeperated = uniqueAnagrams.join(',');\n      //await this.client.set(wordKey, anagramsUniqueCommaSeperated);\n    });\n  }\n\n  search(word) {\n    let sortedWordKey = this.sortStr(word);\n    let anagrams = this.anagramMap.get(sortedWordKey);\n    return anagrams || 'Anagrams not found';\n    /*return new Promise((resolve, reject) => {\n      resolve(anagrams || 'Anagrams not found');\n    });*/\n  }\n\n  loadDictionaryIntoArray() {\n    // get current working directory\n    let cwd = console.log(process.cwd());\n    var dictionary = fs.readFileSync(this.dictionaryFile, 'utf8').split('\\r\\n');\n    return dictionary;\n  }\n  validateAlpha(word) {\n    if (word.match(/^[a-z]+$/)) {\n      return true;\n    }\n    return false;\n  }\n  validateValues(word) {\n    if (word.match(/^[a-z]+,?$/)) {\n      return true;\n    }\n    return false;\n  }\n  // sorts the entire file and stores it in a hash map\n  sortDictionaryWordsIntoRedis(dictionary) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // node js doesn't have tail call recursion so we use a loop\n      for (let word of dictionary) {\n        // will compare words by sorting each char in ascending order\n        let sortedWordKey = this.sortStr(word);\n        //let preExistingWordsInValue = await this.readAnagramsFromRedis(sortedWordKey);\n        //await this.setAnagrams(sortedWordKey, preExistingWordsInValue + this.comma(word));\n      }\n    });\n  }\n\n  preCommaWord(word) {\n    if (word) return `,${word}`;\n  }\n  // NodeJS is probably using merge sort\n  sortStr(word) {\n    return word.split('').sort().join('');\n  }\n}\nexports.Anagram = Anagram;","map":{"version":3,"names":["fs","__importStar","require","Anagram","constructor","dictionaryFile","dictionary","sortedDictionary","anagramSources","anagramMap","Map","Object","freeze","forEach","source","loadAnagrams","lines","responseTextMultiLine","fetchAnagram","split","line","lineToMap","err","console","log","anagramEntry","set","nToEnd","join","n","arr","slice","response","fetch","text","setup","dictionaryArr","loadDictionaryIntoArray","setAnagrams","wordKey","anagramsCommaSeperated","anagrams","cleaned","filter","item","match","search","word","sortedWordKey","sortStr","get","cwd","process","readFileSync","validateAlpha","validateValues","sortDictionaryWordsIntoRedis","preCommaWord","sort","exports"],"sources":["C:\\Users\\nates\\Pro\\anagrams\\react\\src\\lib\\Anagram.ts"],"sourcesContent":["\r\nimport * as fs from 'fs';    // use this for esmodules and typescript\r\n\r\nexport class Anagram {\r\n  public dictionary: string[] = []; \r\n  public sortedDictionary : string[] = [];\r\n  public dictionaryArr: string[] | undefined;\r\n  public client: any;\r\n  public anagramMap: Map<string, string>;\r\n  // easier to read tweak vars up front\r\n  public anagramSources = [\"http://localhost:3000/\", \"http://localhost:3000/anagrams/anagram.txt\", \"http://localhost:3000/anagrams/anagram.sample.txt\"];\r\n  \r\n  constructor(public dictionaryFile: string) {\r\n    this.anagramMap = new Map<string, string>();\r\n    this.dictionaryFile = dictionaryFile; // loads dictionary file\r\n    /*if (!fs.existsSync(this.dictionaryFile)) {\r\n      throw new Error('File not found!');\r\n    }*/\r\n\r\n    // open closed principle (SOLID)\r\n    Object.freeze(this.anagramSources);\r\n    \r\n    this.anagramSources.forEach((source) => this.loadAnagrams(source));\r\n  }\r\n\r\n  async loadAnagrams(source: string) {\r\n    let lines;\r\n    try {\r\n      let responseTextMultiLine = await this.fetchAnagram(source);\r\n      lines = responseTextMultiLine?.split('\\r\\n');\r\n      lines?.forEach((line) => {\r\n        this.lineToMap(line);\r\n      });\r\n    } catch (err) {\r\n      console.log(`Error fetching ${source}: ${err}`);\r\n    }\r\n  }\r\n\r\n  lineToMap(line: string) {\r\n    try {\r\n      let anagramEntry = line.split(',');\r\n      this.anagramMap.set(anagramEntry[0], this.nToEnd(1, anagramEntry).join(','));\r\n    } catch (err) {\r\n      console.log(`Error parsing line: ${line}`);\r\n    }\r\n  }\r\n\r\n  nToEnd(n : number, arr : string[]) {\r\n    return arr.slice(n);\r\n  }\r\n\r\n  async fetchAnagram(source: string) : Promise<string | undefined> {\r\n    let responseTextMultiLine : string;\r\n    try {\r\n      let response = await fetch(source); // timeout?, json?\r\n      responseTextMultiLine = await response.text();\r\n      return responseTextMultiLine;\r\n    } catch (err) {\r\n      console.log(`Error fetching ${source}: ${err}`);\r\n    }\r\n  }\r\n\r\n\r\n  async setup() {\r\n    //await this.client.connect();\r\n    let dictionaryArr = this.loadDictionaryIntoArray();\r\n    //this.sortedDictionary = await this.sortDictionaryWordsIntoRedis(dictionaryArr);\r\n  }\r\n\r\n  // how to preload the dictionary?\r\n  /*\r\n  async readAnagramsFromRedis(sortedWordKey: string) : Promise<string> {\r\n    let commaSeparatedAnagrams = await this.client.get(sortedWordKey);\r\n    let anagramsArr = commaSeparatedAnagrams.split(',').filter((item) => item.match(/^[a-z]+/)); // filter out empty strings\r\n    let anagramsWithCommas = anagramsArr.join(',');\r\n    return anagramsWithCommas;\r\n  }*/\r\n\r\n  async setAnagrams(wordKey: string, anagramsCommaSeperated: string) {\r\n    let anagrams = anagramsCommaSeperated.split(',');\r\n    let cleaned = anagrams.filter((item) => item.match(/^[a-z]+/));\r\n    //let uniqueAnagrams = [...new Set(cleaned)];\r\n    //let anagramsUniqueCommaSeperated = uniqueAnagrams.join(',');\r\n\r\n    //await this.client.set(wordKey, anagramsUniqueCommaSeperated);\r\n  }\r\n\r\n  search(word: string) : string {\r\n    let sortedWordKey = this.sortStr(word);\r\n    let anagrams = this.anagramMap.get(sortedWordKey);\r\n    return anagrams || 'Anagrams not found';\r\n    /*return new Promise((resolve, reject) => {\r\n      resolve(anagrams || 'Anagrams not found');\r\n    });*/\r\n  }\r\n\r\n  loadDictionaryIntoArray(): string[] {\r\n    // get current working directory\r\n    let cwd = console.log(process.cwd());\r\n    var dictionary: string[] = fs.readFileSync(this.dictionaryFile, 'utf8').split('\\r\\n');\r\n    return dictionary;\r\n  }\r\n\r\n  validateAlpha(word: string) {\r\n    if(word.match(/^[a-z]+$/)) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  validateValues(word: string) {\r\n    if(word.match(/^[a-z]+,?$/)) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // sorts the entire file and stores it in a hash map\r\n  async sortDictionaryWordsIntoRedis(dictionary: string[]) { // array passed by reference\r\n    // node js doesn't have tail call recursion so we use a loop\r\n    for(let word of dictionary) {\r\n      // will compare words by sorting each char in ascending order\r\n      let sortedWordKey = this.sortStr(word);\r\n      //let preExistingWordsInValue = await this.readAnagramsFromRedis(sortedWordKey);\r\n      //await this.setAnagrams(sortedWordKey, preExistingWordsInValue + this.comma(word));\r\n    }\r\n  }\r\n\r\n  preCommaWord(word: string) {\r\n    if(word) return `,${word}`;\r\n  }\r\n  \r\n  // NodeJS is probably using merge sort\r\n  sortStr(word: string) : string {\r\n    return word.split('').sort().join(''); \r\n  }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}