{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _RedisClusterSlots_instances, _RedisClusterSlots_options, _RedisClusterSlots_Client, _RedisClusterSlots_onError, _RedisClusterSlots_nodeByAddress, _RedisClusterSlots_slots, _RedisClusterSlots_discoverNodes, _RedisClusterSlots_runningRediscoverPromise, _RedisClusterSlots_rediscover, _RedisClusterSlots_reset, _RedisClusterSlots_clientOptionsDefaults, _RedisClusterSlots_initiateClient, _RedisClusterSlots_getNodeAddress, _RedisClusterSlots_initiateClientForNode, _RedisClusterSlots_slotClientIterator, _RedisClusterSlots_getSlotClient, _RedisClusterSlots_randomClientIterator, _RedisClusterSlots_getRandomClient, _RedisClusterSlots_destroy;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst client_1 = require(\"../client\");\nconst errors_1 = require(\"../errors\");\n// We need to use 'require', because it's not possible with Typescript to import\n// function that are exported as 'module.exports = function`, without esModuleInterop\n// set to true.\nconst calculateSlot = require('cluster-key-slot');\nclass RedisClusterSlots {\n  constructor(options, onError) {\n    _RedisClusterSlots_instances.add(this);\n    _RedisClusterSlots_options.set(this, void 0);\n    _RedisClusterSlots_Client.set(this, void 0);\n    _RedisClusterSlots_onError.set(this, void 0);\n    _RedisClusterSlots_nodeByAddress.set(this, new Map());\n    _RedisClusterSlots_slots.set(this, []);\n    _RedisClusterSlots_runningRediscoverPromise.set(this, void 0);\n    _RedisClusterSlots_randomClientIterator.set(this, void 0);\n    __classPrivateFieldSet(this, _RedisClusterSlots_options, options, \"f\");\n    __classPrivateFieldSet(this, _RedisClusterSlots_Client, client_1.default.extend(options), \"f\");\n    __classPrivateFieldSet(this, _RedisClusterSlots_onError, onError, \"f\");\n  }\n  async connect() {\n    for (const rootNode of __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").rootNodes) {\n      if (await __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_discoverNodes).call(this, rootNode)) return;\n    }\n    throw new errors_1.RootNodesUnavailableError();\n  }\n  async rediscover(startWith) {\n    if (!__classPrivateFieldGet(this, _RedisClusterSlots_runningRediscoverPromise, \"f\")) {\n      __classPrivateFieldSet(this, _RedisClusterSlots_runningRediscoverPromise, __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_rediscover).call(this, startWith).finally(() => __classPrivateFieldSet(this, _RedisClusterSlots_runningRediscoverPromise, undefined, \"f\")), \"f\");\n    }\n    return __classPrivateFieldGet(this, _RedisClusterSlots_runningRediscoverPromise, \"f\");\n  }\n  getSlotMaster(slot) {\n    return __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\")[slot].master;\n  }\n  getClient(firstKey, isReadonly) {\n    if (!firstKey) {\n      return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getRandomClient).call(this);\n    }\n    const slot = calculateSlot(firstKey);\n    if (!isReadonly || !__classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").useReplicas) {\n      return this.getSlotMaster(slot).client;\n    }\n    return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getSlotClient).call(this, slot);\n  }\n  getMasters() {\n    const masters = [];\n    for (const node of __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").values()) {\n      if (node.client.options?.readonly) continue;\n      masters.push(node);\n    }\n    return masters;\n  }\n  getNodeByAddress(address) {\n    const mappedAddress = __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getNodeAddress).call(this, address);\n    return __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").get(mappedAddress ? `${mappedAddress.host}:${mappedAddress.port}` : address);\n  }\n  quit() {\n    return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_destroy).call(this, client => client.quit());\n  }\n  disconnect() {\n    return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_destroy).call(this, client => client.disconnect());\n  }\n}\nexports.default = RedisClusterSlots;\n_RedisClusterSlots_options = new WeakMap(), _RedisClusterSlots_Client = new WeakMap(), _RedisClusterSlots_onError = new WeakMap(), _RedisClusterSlots_nodeByAddress = new WeakMap(), _RedisClusterSlots_slots = new WeakMap(), _RedisClusterSlots_runningRediscoverPromise = new WeakMap(), _RedisClusterSlots_randomClientIterator = new WeakMap(), _RedisClusterSlots_instances = new WeakSet(), _RedisClusterSlots_discoverNodes = async function _RedisClusterSlots_discoverNodes(clientOptions) {\n  const client = __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_initiateClient).call(this, clientOptions);\n  await client.connect();\n  try {\n    await __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_reset).call(this, await client.clusterNodes());\n    return true;\n  } catch (err) {\n    __classPrivateFieldGet(this, _RedisClusterSlots_onError, \"f\").call(this, err);\n    return false;\n  } finally {\n    if (client.isOpen) {\n      await client.disconnect();\n    }\n  }\n}, _RedisClusterSlots_rediscover = async function _RedisClusterSlots_rediscover(startWith) {\n  if (await __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_discoverNodes).call(this, startWith.options)) return;\n  for (const {\n    client\n  } of __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").values()) {\n    if (client === startWith) continue;\n    if (await __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_discoverNodes).call(this, client.options)) return;\n  }\n  throw new Error('None of the cluster nodes is available');\n}, _RedisClusterSlots_reset = async function _RedisClusterSlots_reset(masters) {\n  // Override this.#slots and add not existing clients to this.#nodeByAddress\n  const promises = [],\n    clientsInUse = new Set();\n  for (const master of masters) {\n    const slot = {\n      master: __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_initiateClientForNode).call(this, master, false, clientsInUse, promises),\n      replicas: __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").useReplicas ? master.replicas.map(replica => __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_initiateClientForNode).call(this, replica, true, clientsInUse, promises)) : [],\n      clientIterator: undefined // will be initiated in use\n    };\n\n    for (const {\n      from,\n      to\n    } of master.slots) {\n      for (let i = from; i <= to; i++) {\n        __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\")[i] = slot;\n      }\n    }\n  }\n  // Remove unused clients from this.#nodeByAddress using clientsInUse\n  for (const [address, {\n    client\n  }] of __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").entries()) {\n    if (clientsInUse.has(address)) continue;\n    promises.push(client.disconnect());\n    __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").delete(address);\n  }\n  await Promise.all(promises);\n}, _RedisClusterSlots_clientOptionsDefaults = function _RedisClusterSlots_clientOptionsDefaults(options) {\n  if (!__classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults) return options;\n  return {\n    ...__classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults,\n    ...options,\n    socket: __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults.socket && options?.socket ? {\n      ...__classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults.socket,\n      ...options.socket\n    } : __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults.socket ?? options?.socket\n  };\n}, _RedisClusterSlots_initiateClient = function _RedisClusterSlots_initiateClient(options) {\n  return new (__classPrivateFieldGet(this, _RedisClusterSlots_Client, \"f\"))(__classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_clientOptionsDefaults).call(this, options)).on('error', __classPrivateFieldGet(this, _RedisClusterSlots_onError, \"f\"));\n}, _RedisClusterSlots_getNodeAddress = function _RedisClusterSlots_getNodeAddress(address) {\n  switch (typeof __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").nodeAddressMap) {\n    case 'object':\n      return __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").nodeAddressMap[address];\n    case 'function':\n      return __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").nodeAddressMap(address);\n  }\n}, _RedisClusterSlots_initiateClientForNode = function _RedisClusterSlots_initiateClientForNode(nodeData, readonly, clientsInUse, promises) {\n  const address = `${nodeData.host}:${nodeData.port}`;\n  clientsInUse.add(address);\n  let node = __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").get(address);\n  if (!node) {\n    node = {\n      id: nodeData.id,\n      client: __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_initiateClient).call(this, {\n        socket: __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getNodeAddress).call(this, address) ?? {\n          host: nodeData.host,\n          port: nodeData.port\n        },\n        readonly\n      })\n    };\n    promises.push(node.client.connect());\n    __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").set(address, node);\n  }\n  return node;\n}, _RedisClusterSlots_slotClientIterator = function* _RedisClusterSlots_slotClientIterator(slotNumber) {\n  const slot = __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\")[slotNumber];\n  yield slot.master.client;\n  for (const replica of slot.replicas) {\n    yield replica.client;\n  }\n}, _RedisClusterSlots_getSlotClient = function _RedisClusterSlots_getSlotClient(slotNumber) {\n  const slot = __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\")[slotNumber];\n  if (!slot.clientIterator) {\n    slot.clientIterator = __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_slotClientIterator).call(this, slotNumber);\n  }\n  const {\n    done,\n    value\n  } = slot.clientIterator.next();\n  if (done) {\n    slot.clientIterator = undefined;\n    return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getSlotClient).call(this, slotNumber);\n  }\n  return value;\n}, _RedisClusterSlots_getRandomClient = function _RedisClusterSlots_getRandomClient() {\n  if (!__classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").size) {\n    throw new Error('Cluster is not connected');\n  }\n  if (!__classPrivateFieldGet(this, _RedisClusterSlots_randomClientIterator, \"f\")) {\n    __classPrivateFieldSet(this, _RedisClusterSlots_randomClientIterator, __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").values(), \"f\");\n  }\n  const {\n    done,\n    value\n  } = __classPrivateFieldGet(this, _RedisClusterSlots_randomClientIterator, \"f\").next();\n  if (done) {\n    __classPrivateFieldSet(this, _RedisClusterSlots_randomClientIterator, undefined, \"f\");\n    return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getRandomClient).call(this);\n  }\n  return value.client;\n}, _RedisClusterSlots_destroy = async function _RedisClusterSlots_destroy(fn) {\n  const promises = [];\n  for (const {\n    client\n  } of __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").values()) {\n    promises.push(fn(client));\n  }\n  await Promise.all(promises);\n  __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").clear();\n  __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\").splice(0);\n};","map":{"version":3,"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","_RedisClusterSlots_instances","_RedisClusterSlots_options","_RedisClusterSlots_Client","_RedisClusterSlots_onError","_RedisClusterSlots_nodeByAddress","_RedisClusterSlots_slots","_RedisClusterSlots_discoverNodes","_RedisClusterSlots_runningRediscoverPromise","_RedisClusterSlots_rediscover","_RedisClusterSlots_reset","_RedisClusterSlots_clientOptionsDefaults","_RedisClusterSlots_initiateClient","_RedisClusterSlots_getNodeAddress","_RedisClusterSlots_initiateClientForNode","_RedisClusterSlots_slotClientIterator","_RedisClusterSlots_getSlotClient","_RedisClusterSlots_randomClientIterator","_RedisClusterSlots_getRandomClient","_RedisClusterSlots_destroy","Object","defineProperty","exports","client_1","require","errors_1","calculateSlot","RedisClusterSlots","constructor","options","onError","add","Map","default","extend","connect","rootNode","rootNodes","RootNodesUnavailableError","rediscover","startWith","finally","undefined","getSlotMaster","slot","master","getClient","firstKey","isReadonly","useReplicas","client","getMasters","masters","node","values","readonly","push","getNodeByAddress","address","mappedAddress","host","port","quit","disconnect","WeakMap","WeakSet","clientOptions","clusterNodes","err","isOpen","Error","promises","clientsInUse","Set","replicas","map","replica","clientIterator","from","to","slots","i","entries","delete","Promise","all","defaults","socket","on","nodeAddressMap","nodeData","id","slotNumber","done","next","size","fn","clear","splice"],"sources":["C:/Users/nates/Pro/anagrams/node_modules/@redis/client/dist/lib/cluster/cluster-slots.js"],"sourcesContent":["\"use strict\";\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _RedisClusterSlots_instances, _RedisClusterSlots_options, _RedisClusterSlots_Client, _RedisClusterSlots_onError, _RedisClusterSlots_nodeByAddress, _RedisClusterSlots_slots, _RedisClusterSlots_discoverNodes, _RedisClusterSlots_runningRediscoverPromise, _RedisClusterSlots_rediscover, _RedisClusterSlots_reset, _RedisClusterSlots_clientOptionsDefaults, _RedisClusterSlots_initiateClient, _RedisClusterSlots_getNodeAddress, _RedisClusterSlots_initiateClientForNode, _RedisClusterSlots_slotClientIterator, _RedisClusterSlots_getSlotClient, _RedisClusterSlots_randomClientIterator, _RedisClusterSlots_getRandomClient, _RedisClusterSlots_destroy;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst client_1 = require(\"../client\");\nconst errors_1 = require(\"../errors\");\n// We need to use 'require', because it's not possible with Typescript to import\n// function that are exported as 'module.exports = function`, without esModuleInterop\n// set to true.\nconst calculateSlot = require('cluster-key-slot');\nclass RedisClusterSlots {\n    constructor(options, onError) {\n        _RedisClusterSlots_instances.add(this);\n        _RedisClusterSlots_options.set(this, void 0);\n        _RedisClusterSlots_Client.set(this, void 0);\n        _RedisClusterSlots_onError.set(this, void 0);\n        _RedisClusterSlots_nodeByAddress.set(this, new Map());\n        _RedisClusterSlots_slots.set(this, []);\n        _RedisClusterSlots_runningRediscoverPromise.set(this, void 0);\n        _RedisClusterSlots_randomClientIterator.set(this, void 0);\n        __classPrivateFieldSet(this, _RedisClusterSlots_options, options, \"f\");\n        __classPrivateFieldSet(this, _RedisClusterSlots_Client, client_1.default.extend(options), \"f\");\n        __classPrivateFieldSet(this, _RedisClusterSlots_onError, onError, \"f\");\n    }\n    async connect() {\n        for (const rootNode of __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").rootNodes) {\n            if (await __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_discoverNodes).call(this, rootNode))\n                return;\n        }\n        throw new errors_1.RootNodesUnavailableError();\n    }\n    async rediscover(startWith) {\n        if (!__classPrivateFieldGet(this, _RedisClusterSlots_runningRediscoverPromise, \"f\")) {\n            __classPrivateFieldSet(this, _RedisClusterSlots_runningRediscoverPromise, __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_rediscover).call(this, startWith)\n                .finally(() => __classPrivateFieldSet(this, _RedisClusterSlots_runningRediscoverPromise, undefined, \"f\")), \"f\");\n        }\n        return __classPrivateFieldGet(this, _RedisClusterSlots_runningRediscoverPromise, \"f\");\n    }\n    getSlotMaster(slot) {\n        return __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\")[slot].master;\n    }\n    getClient(firstKey, isReadonly) {\n        if (!firstKey) {\n            return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getRandomClient).call(this);\n        }\n        const slot = calculateSlot(firstKey);\n        if (!isReadonly || !__classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").useReplicas) {\n            return this.getSlotMaster(slot).client;\n        }\n        return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getSlotClient).call(this, slot);\n    }\n    getMasters() {\n        const masters = [];\n        for (const node of __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").values()) {\n            if (node.client.options?.readonly)\n                continue;\n            masters.push(node);\n        }\n        return masters;\n    }\n    getNodeByAddress(address) {\n        const mappedAddress = __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getNodeAddress).call(this, address);\n        return __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").get(mappedAddress ? `${mappedAddress.host}:${mappedAddress.port}` : address);\n    }\n    quit() {\n        return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_destroy).call(this, client => client.quit());\n    }\n    disconnect() {\n        return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_destroy).call(this, client => client.disconnect());\n    }\n}\nexports.default = RedisClusterSlots;\n_RedisClusterSlots_options = new WeakMap(), _RedisClusterSlots_Client = new WeakMap(), _RedisClusterSlots_onError = new WeakMap(), _RedisClusterSlots_nodeByAddress = new WeakMap(), _RedisClusterSlots_slots = new WeakMap(), _RedisClusterSlots_runningRediscoverPromise = new WeakMap(), _RedisClusterSlots_randomClientIterator = new WeakMap(), _RedisClusterSlots_instances = new WeakSet(), _RedisClusterSlots_discoverNodes = async function _RedisClusterSlots_discoverNodes(clientOptions) {\n    const client = __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_initiateClient).call(this, clientOptions);\n    await client.connect();\n    try {\n        await __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_reset).call(this, await client.clusterNodes());\n        return true;\n    }\n    catch (err) {\n        __classPrivateFieldGet(this, _RedisClusterSlots_onError, \"f\").call(this, err);\n        return false;\n    }\n    finally {\n        if (client.isOpen) {\n            await client.disconnect();\n        }\n    }\n}, _RedisClusterSlots_rediscover = async function _RedisClusterSlots_rediscover(startWith) {\n    if (await __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_discoverNodes).call(this, startWith.options))\n        return;\n    for (const { client } of __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").values()) {\n        if (client === startWith)\n            continue;\n        if (await __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_discoverNodes).call(this, client.options))\n            return;\n    }\n    throw new Error('None of the cluster nodes is available');\n}, _RedisClusterSlots_reset = async function _RedisClusterSlots_reset(masters) {\n    // Override this.#slots and add not existing clients to this.#nodeByAddress\n    const promises = [], clientsInUse = new Set();\n    for (const master of masters) {\n        const slot = {\n            master: __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_initiateClientForNode).call(this, master, false, clientsInUse, promises),\n            replicas: __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").useReplicas ?\n                master.replicas.map(replica => __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_initiateClientForNode).call(this, replica, true, clientsInUse, promises)) :\n                [],\n            clientIterator: undefined // will be initiated in use\n        };\n        for (const { from, to } of master.slots) {\n            for (let i = from; i <= to; i++) {\n                __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\")[i] = slot;\n            }\n        }\n    }\n    // Remove unused clients from this.#nodeByAddress using clientsInUse\n    for (const [address, { client }] of __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").entries()) {\n        if (clientsInUse.has(address))\n            continue;\n        promises.push(client.disconnect());\n        __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").delete(address);\n    }\n    await Promise.all(promises);\n}, _RedisClusterSlots_clientOptionsDefaults = function _RedisClusterSlots_clientOptionsDefaults(options) {\n    if (!__classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults)\n        return options;\n    return {\n        ...__classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults,\n        ...options,\n        socket: __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults.socket && options?.socket ? {\n            ...__classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults.socket,\n            ...options.socket\n        } : __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").defaults.socket ?? options?.socket\n    };\n}, _RedisClusterSlots_initiateClient = function _RedisClusterSlots_initiateClient(options) {\n    return new (__classPrivateFieldGet(this, _RedisClusterSlots_Client, \"f\"))(__classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_clientOptionsDefaults).call(this, options))\n        .on('error', __classPrivateFieldGet(this, _RedisClusterSlots_onError, \"f\"));\n}, _RedisClusterSlots_getNodeAddress = function _RedisClusterSlots_getNodeAddress(address) {\n    switch (typeof __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").nodeAddressMap) {\n        case 'object':\n            return __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").nodeAddressMap[address];\n        case 'function':\n            return __classPrivateFieldGet(this, _RedisClusterSlots_options, \"f\").nodeAddressMap(address);\n    }\n}, _RedisClusterSlots_initiateClientForNode = function _RedisClusterSlots_initiateClientForNode(nodeData, readonly, clientsInUse, promises) {\n    const address = `${nodeData.host}:${nodeData.port}`;\n    clientsInUse.add(address);\n    let node = __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").get(address);\n    if (!node) {\n        node = {\n            id: nodeData.id,\n            client: __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_initiateClient).call(this, {\n                socket: __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getNodeAddress).call(this, address) ?? {\n                    host: nodeData.host,\n                    port: nodeData.port\n                },\n                readonly\n            })\n        };\n        promises.push(node.client.connect());\n        __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").set(address, node);\n    }\n    return node;\n}, _RedisClusterSlots_slotClientIterator = function* _RedisClusterSlots_slotClientIterator(slotNumber) {\n    const slot = __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\")[slotNumber];\n    yield slot.master.client;\n    for (const replica of slot.replicas) {\n        yield replica.client;\n    }\n}, _RedisClusterSlots_getSlotClient = function _RedisClusterSlots_getSlotClient(slotNumber) {\n    const slot = __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\")[slotNumber];\n    if (!slot.clientIterator) {\n        slot.clientIterator = __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_slotClientIterator).call(this, slotNumber);\n    }\n    const { done, value } = slot.clientIterator.next();\n    if (done) {\n        slot.clientIterator = undefined;\n        return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getSlotClient).call(this, slotNumber);\n    }\n    return value;\n}, _RedisClusterSlots_getRandomClient = function _RedisClusterSlots_getRandomClient() {\n    if (!__classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").size) {\n        throw new Error('Cluster is not connected');\n    }\n    if (!__classPrivateFieldGet(this, _RedisClusterSlots_randomClientIterator, \"f\")) {\n        __classPrivateFieldSet(this, _RedisClusterSlots_randomClientIterator, __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").values(), \"f\");\n    }\n    const { done, value } = __classPrivateFieldGet(this, _RedisClusterSlots_randomClientIterator, \"f\").next();\n    if (done) {\n        __classPrivateFieldSet(this, _RedisClusterSlots_randomClientIterator, undefined, \"f\");\n        return __classPrivateFieldGet(this, _RedisClusterSlots_instances, \"m\", _RedisClusterSlots_getRandomClient).call(this);\n    }\n    return value.client;\n}, _RedisClusterSlots_destroy = async function _RedisClusterSlots_destroy(fn) {\n    const promises = [];\n    for (const { client } of __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").values()) {\n        promises.push(fn(client));\n    }\n    await Promise.all(promises);\n    __classPrivateFieldGet(this, _RedisClusterSlots_nodeByAddress, \"f\").clear();\n    __classPrivateFieldGet(this, _RedisClusterSlots_slots, \"f\").splice(0);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}